# Transformable Content Best Practices

## When to Use
- Any zoomable/pannable content
- Programmatic focus requirements
- Complex gesture interactions

## Implementation Notes
1. Always:
   - Use `snapshotFlow` for state synchronization
   - Cache matrix operations
   - Handle edge cases (empty bounds, extreme zooms)

2. Avoid:
   - Direct matrix manipulation outside state
   - Multiple transformation sources
   - Ignoring content size changes

## Performance
- Reuse FloatArray for matrix values
- Minimize allocations in gesture handlers
- Pre-calculate expensive bounds math

## Transformable Content Animation Patterns

### Problem Statement
Implement smooth zoom/pan animations with programmatic focus that:
1. Respects gesture interactions
2. Avoids state desynchronization
3. Maintains 60fps performance

### Root Cause Analysis (Five Whys)
1. **Problem**: Jumps between gestures and animations  
   **Why?**: Matrix and Animatable states were desynchronized  
   **Solution**: Single source of truth via `MatrixAnimator`

### Key Learnings
1. **Unified Transformation Pipeline**:
   ```kotlin
   class MatrixAnimator(initial: Matrix, spec: AnimationSpec<Matrix>) {
       private val animatable = Animatable(initial, MatrixVectorConverter)
       // Single source for all transformations
   }
   ```
2. **Proper Matrix Animation**:
   - Implemented `TwoWayConverter<Matrix, AnimationVector4D>`
   - Syncs scale (X/Y) and translation (X/Y) as a single unit

3. **Gesture-Animation Harmony**:
   - Always check `!state.isAnimating` before handling gestures
   - Snap matrix state immediately on gesture start

### Best Practices
1. **For Animation**:
   ```kotlin
   suspend fun focusOn(bounds: Rect) {
       isAnimating = true
       try {
           matrixAnimator.animateTo(targetMatrix) // Physics-based
       } finally {
           isAnimating = false // Always reset
       }
   }
   ```
2. **For Performance**:
   - Use `derivedStateOf` for zoom/offset to minimize recomposition
   - Cache `FloatArray(9)` for matrix operations

3. **Edge Cases Handled**:
   - Interrupted animations
   - Minimum/maximum zoom clamping
   - Empty content bounds

### Zoom Clamping Pattern (NEW)

**Problem**: Users can zoom beyond usable limits, causing performance issues and poor UX.

**Solution**: Implement gesture-level zoom limits with revert-to-original approach:
```kotlin
private const val MIN_ZOOM = 0.1f
private const val MAX_ZOOM = 10f

// In gesture handler:
val originalMatrix = Matrix(matrix)
matrix.postScale(zoomChange, zoomChange, centroid.x, centroid.y)

val currentZoom = getMatrixScale(matrix)
if (currentZoom !in MIN_ZOOM..MAX_ZOOM) {
    matrix.set(originalMatrix) // Revert and skip pan
    return@detectTransformGestures
}
// Continue with pan logic...
```

**Key Benefits**:
- Prevents matrix shift artifacts (vs direct clamping)
- Separates zoom/pan operations for better UX
- Maintains gesture responsiveness at limits

### Visualization of the Solution
```
[Gesture] → [Update Matrix] → [Sync State]  
[Animation] → [MatrixAnimator] → [Single Source of Truth]
```

### Code Healthy Metrics
- **Coupling**: Low (MatrixAnimator encapsulates all transform logic)
- **Cohesion**: High (All transformation code in one class)
- **Performance**: No frame drops during 10K+ matrix ops/s in tests

### Future Improvements
1. Add debug overlays for transformation origin points
2. Support pinch-zoom pivot point animations
3. Document spring tuning parameters:
   ```kotlin
   spring(
       stiffness = 800f, 
       dampingRatio = 0.6f 
   )
   ```

---

# Android Media Permissions System Patterns (NEW)

## Problem Statement
Implement modern Android media permissions that:
1. Support Android 10-15 with different permission models
2. Handle Android 14+ "Limited Access" transparently
3. Provide excellent UX without over-engineering

## Root Cause Analysis (Five Whys)
1. **Problem**: App stuck on permission screen after granting limited access
   **Why?**: Only checking `READ_MEDIA_IMAGES`/`READ_MEDIA_VIDEO` permissions
   **Why?**: Didn't account for Android 14's `READ_MEDIA_VISUAL_USER_SELECTED`
   **Solution**: Check for either full OR limited access permissions

2. **Problem**: Complex permission state management
   **Why?**: Tried to detect and handle "limited access" as separate state
   **Why?**: Misunderstood that limited access should be transparent to app
   **Solution**: Simplified to binary "has access" vs "no access"

## Key Learnings

### 1. Android Permission Evolution Strategy
```kotlin
// Android 14+ - Check for either full OR limited access
val hasFullAccess = (READ_MEDIA_IMAGES granted || READ_MEDIA_VIDEO granted)
val hasLimitedAccess = READ_MEDIA_VISUAL_USER_SELECTED granted

// Treat limited access same as full access - system handles the difference
val effectiveAccess = hasFullAccess || hasLimitedAccess
```

### 2. Don't Over-Engineer Permission States
**Anti-Pattern**: Complex state machines with GRANTED/LIMITED/DENIED/PERMANENTLY_DENIED
```kotlin
// ❌ Over-engineered
enum class MediaPermissionState {
    GRANTED, LIMITED, DENIED, PERMANENTLY_DENIED, NOT_REQUESTED
}
```

**Best Practice**: Simple binary approach
```kotlin
// ✅ Simple and effective  
enum class MediaPermissionState {
    GRANTED, DENIED, NOT_REQUESTED
}
```

### 3. Let the System Handle Complexity
- **Limited Access**: System provides only selected photos to MediaStore queries
- **Permanent Denial**: Android 11+ automatically stops showing dialogs after 2+ denials  
- **Rationale**: Modern apps show good upfront explanation instead of complex rationale API

### 4. Modern Permission UX Pattern
```kotlin
// Clean flow: Request → Has Access? → Show Content
when {
    permissionStatus.hasMediaAccess -> showGallery()
    else -> showPermissionRequest()
}
```

## Best Practices

### 1. Version-Appropriate Permission Sets
```kotlin
private val requiredPermissions = when {
    Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE -> {
        // Android 14+ - Include limited access permission
        arrayOf(READ_MEDIA_IMAGES, READ_MEDIA_VIDEO, READ_MEDIA_VISUAL_USER_SELECTED)
    }
    Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {
        // Android 13 - Granular media permissions
        arrayOf(READ_MEDIA_IMAGES, READ_MEDIA_VIDEO)
    }
    else -> {
        // Android 10-12 - Legacy storage permission
        arrayOf(READ_EXTERNAL_STORAGE)
    }
}
```

### 2. Single Permission Request
```kotlin
// Request all permissions in one operation per Android docs
permissionLauncher.launch(permissionManager.getAllPermissions())
```

### 3. Minimum SDK Strategy
- **Bump to API 29** eliminates Android 9 edge cases
- **Cleaner permission model** throughout supported range
- **97%+ device coverage** with much simpler code

## Code Health Metrics
- **Reduced complexity**: Removed 5 unused states/composables  
- **Better UX**: No complex "permanently denied" flows
- **Maintenance**: Single permission detection path per Android version

## Anti-Patterns Avoided
1. **Tracking permanent denial manually** - Let Android handle it
2. **Complex limited access UI** - Treat as transparent to app
3. **Multiple permission request flows** - Use single Material3 bottom sheet
4. **Supporting very old Android versions** - Focus on modern baseline

## Future Considerations
1. **Photo Picker Integration**: For apps wanting zero permissions
2. **Scoped Storage Optimization**: Direct file access patterns for Android 11+
3. **Privacy Dashboard**: Prepare for enhanced permission monitoring

### Visualization of the Solution
```
User Action → System Permission Dialog → Binary Result
[Allow All] → READ_MEDIA_* granted → App sees all photos
[Allow Limited] → READ_MEDIA_VISUAL_USER_SELECTED granted → App sees selected photos  
[Deny] → No permissions → Show retry option
```

---

# Atlas-Based Media Rendering System (NEW)

## Problem Statement
Replace Coil-based image loading with custom atlas system for:
1. Large-scale hex grid canvas with hundreds/thousands of images
2. Zoom-level optimized rendering (LOD - Level of Detail)
3. Precise memory and GPU texture control
4. Seamless performance across zoom ranges

## Why Atlas Over Individual Images?
**Performance Issues with Coil:**
- Creates thousands of individual bitmap objects
- Uncontrolled memory usage and GPU texture thrashing  
- No zoom-level optimization (always loads same resolution)
- Excessive draw calls (one per image vs one per atlas)

**Atlas Benefits:**
- Single large bitmap per zoom level
- Massive reduction in GPU texture switches
- Perfect memory control and predictable usage
- Zoom-optimized rendering with multiple detail levels

## Core Design Principles

### 1. Single Atlas Focus (Phase 1)
Before implementing multiple LOD levels, solve fundamental problems:
- **Atlas Size**: Optimal balance between memory usage and texture limits
- **Packing Algorithm**: How to arrange hundreds of thumbnails efficiently
- **Image Data Storage**: Maintain mapping from media → atlas coordinates
- **Region Retrieval**: Fast lookup of image regions within atlas

### 2. Key Technical Challenges

#### Atlas Size Strategy
```kotlin
// Target: Balance memory vs texture limits
// Android GPU texture limit: typically 4096x4096 or 8192x8192
// Optimal atlas size: 2048x2048 (4MB at ARGB_8888)

val ATLAS_SIZE = 2048 // pixels
val THUMBNAIL_SIZE = 128 // pixels  
val THUMBNAILS_PER_ATLAS = (ATLAS_SIZE / THUMBNAIL_SIZE).pow(2) // 256 thumbnails
```

#### Image Data Storage Pattern
```kotlin
data class AtlasRegion(
    val x: Int,        // pixel offset in atlas
    val y: Int,        // pixel offset in atlas  
    val width: Int,    // region width
    val height: Int,   // region height
    val atlasId: Int   // which atlas contains this image
)

class AtlasManager {
    private val mediaToRegion = mutableMapOf<Media, AtlasRegion>()
    private val atlases = mutableListOf<Bitmap>()
    
    fun getRegion(media: Media): AtlasRegion?
    fun packThumbnail(media: Media, thumbnail: Bitmap): AtlasRegion
}
```

#### Packing Algorithm Options
1. **Simple Grid**: Fixed 128x128 slots in 16x16 grid
2. **Bin Packing**: Variable sizes, optimal space usage
3. **Hybrid**: Fixed rows with variable column widths

#### Atlas Generation Architecture
- **Location**: Data layer during media loading (not UI layer)
- **Approach**: Offscreen rendering solution
- **Candidates**: ImageWriter with Surface, hardware Canvas
- **Goal**: Generate atlas bitmaps independent of UI thread

## Implementation Strategy

### Phase 1: Single Atlas Foundation
1. **Remove Coil dependency** - Replace with native thumbnail generation
2. **Atlas packing system** - Simple grid-based approach first
3. **Region mapping** - Media → AtlasRegion lookup table
4. **Canvas integration** - Update MediaHexVisualization to use atlas

### Phase 2: Multiple LOD Levels (Future)
```kotlin
// Future LOD system based on zoom ranges
Level 0: zoom 0.1-0.5  → 32px thumbs  (overview)
Level 1: zoom 0.5-2.0  → 128px thumbs (navigation) 
Level 2: zoom 2.0-8.0  → 512px thumbs (browsing)
Level 3: zoom 8.0+     → full res     (detail)
```

## Key Technical Questions (Phase 1)
1. **Atlas Size**: Start with 2048x2048 or test device limits?
2. **Thumbnail Generation**: `ThumbnailUtils.extractThumbnail()` vs `ImageDecoder`?
3. **Packing Strategy**: Fixed grid vs bin packing for first iteration?
4. **Memory Management**: Single atlas vs multiple smaller atlases?
5. **Threading**: Background atlas generation vs on-demand?
6. **Offscreen Rendering**: Best approach for atlas generation outside UI?

## Success Metrics
- **Memory Usage**: Predictable and bounded per zoom level
- **Draw Calls**: 1 per atlas region vs 1 per individual image
- **Frame Rate**: Stable 60fps during pan/zoom operations
- **Load Time**: Fast atlas generation for hundreds of images