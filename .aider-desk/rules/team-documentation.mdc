# Transformable Content Best Practices

## When to Use
- Any zoomable/pannable content
- Programmatic focus requirements
- Complex gesture interactions

## Implementation Notes
1. Always:
   - Use `snapshotFlow` for state synchronization
   - Cache matrix operations
   - Handle edge cases (empty bounds, extreme zooms)

2. Avoid:
   - Direct matrix manipulation outside state
   - Multiple transformation sources
   - Ignoring content size changes

## Performance
- Reuse FloatArray for matrix values
- Minimize allocations in gesture handlers
- Pre-calculate expensive bounds math

## Transformable Content Animation Patterns

### Problem Statement
Implement smooth zoom/pan animations with programmatic focus that:
1. Respects gesture interactions
2. Avoids state desynchronization
3. Maintains 60fps performance

### Root Cause Analysis (Five Whys)
1. **Problem**: Jumps between gestures and animations  
   **Why?**: Matrix and Animatable states were desynchronized  
   **Solution**: Single source of truth via `MatrixAnimator`

### Key Learnings
1. **Unified Transformation Pipeline**:
   ```kotlin
   class MatrixAnimator(initial: Matrix, spec: AnimationSpec<Matrix>) {
       private val animatable = Animatable(initial, MatrixVectorConverter)
       // Single source for all transformations
   }
   ```
2. **Proper Matrix Animation**:
   - Implemented `TwoWayConverter<Matrix, AnimationVector4D>`
   - Syncs scale (X/Y) and translation (X/Y) as a single unit

3. **Gesture-Animation Harmony**:
   - Always check `!state.isAnimating` before handling gestures
   - Snap matrix state immediately on gesture start

### Best Practices
1. **For Animation**:
   ```kotlin
   suspend fun focusOn(bounds: Rect) {
       isAnimating = true
       try {
           matrixAnimator.animateTo(targetMatrix) // Physics-based
       } finally {
           isAnimating = false // Always reset
       }
   }
   ```
2. **For Performance**:
   - Use `derivedStateOf` for zoom/offset to minimize recomposition
   - Cache `FloatArray(9)` for matrix operations

3. **Edge Cases Handled**:
   - Interrupted animations
   - Minimum/maximum zoom clamping
   - Empty content bounds

### Zoom Clamping Pattern (NEW)

**Problem**: Users can zoom beyond usable limits, causing performance issues and poor UX.

**Solution**: Implement gesture-level zoom limits with revert-to-original approach:
```kotlin
private const val MIN_ZOOM = 0.1f
private const val MAX_ZOOM = 10f

// In gesture handler:
val originalMatrix = Matrix(matrix)
matrix.postScale(zoomChange, zoomChange, centroid.x, centroid.y)

val currentZoom = getMatrixScale(matrix)
if (currentZoom !in MIN_ZOOM..MAX_ZOOM) {
    matrix.set(originalMatrix) // Revert and skip pan
    return@detectTransformGestures
}
// Continue with pan logic...
```

**Key Benefits**:
- Prevents matrix shift artifacts (vs direct clamping)
- Separates zoom/pan operations for better UX
- Maintains gesture responsiveness at limits

### Visualization of the Solution
```
[Gesture] → [Update Matrix] → [Sync State]  
[Animation] → [MatrixAnimator] → [Single Source of Truth]
```

### Code Healthy Metrics
- **Coupling**: Low (MatrixAnimator encapsulates all transform logic)
- **Cohesion**: High (All transformation code in one class)
- **Performance**: No frame drops during 10K+ matrix ops/s in tests

### Future Improvements
1. Add debug overlays for transformation origin points
2. Support pinch-zoom pivot point animations
3. Document spring tuning parameters:
   ```kotlin
   spring(
       stiffness = 800f, 
       dampingRatio = 0.6f 
   )
   ```

---

# Android Media Permissions System Patterns (NEW)

## Problem Statement
Implement modern Android media permissions that:
1. Support Android 10-15 with different permission models
2. Handle Android 14+ "Limited Access" transparently
3. Provide excellent UX without over-engineering

## Root Cause Analysis (Five Whys)
1. **Problem**: App stuck on permission screen after granting limited access
   **Why?**: Only checking `READ_MEDIA_IMAGES`/`READ_MEDIA_VIDEO` permissions
   **Why?**: Didn't account for Android 14's `READ_MEDIA_VISUAL_USER_SELECTED`
   **Solution**: Check for either full OR limited access permissions

2. **Problem**: Complex permission state management
   **Why?**: Tried to detect and handle "limited access" as separate state
   **Why?**: Misunderstood that limited access should be transparent to app
   **Solution**: Simplified to binary "has access" vs "no access"

## Key Learnings

### 1. Android Permission Evolution Strategy
```kotlin
// Android 14+ - Check for either full OR limited access
val hasFullAccess = (READ_MEDIA_IMAGES granted || READ_MEDIA_VIDEO granted)
val hasLimitedAccess = READ_MEDIA_VISUAL_USER_SELECTED granted

// Treat limited access same as full access - system handles the difference
val effectiveAccess = hasFullAccess || hasLimitedAccess
```

### 2. Don't Over-Engineer Permission States
**Anti-Pattern**: Complex state machines with GRANTED/LIMITED/DENIED/PERMANENTLY_DENIED
```kotlin
// ❌ Over-engineered
enum class MediaPermissionState {
    GRANTED, LIMITED, DENIED, PERMANENTLY_DENIED, NOT_REQUESTED
}
```

**Best Practice**: Simple binary approach
```kotlin
// ✅ Simple and effective  
enum class MediaPermissionState {
    GRANTED, DENIED, NOT_REQUESTED
}
```

### 3. Let the System Handle Complexity
- **Limited Access**: System provides only selected photos to MediaStore queries
- **Permanent Denial**: Android 11+ automatically stops showing dialogs after 2+ denials  
- **Rationale**: Modern apps show good upfront explanation instead of complex rationale API

### 4. Modern Permission UX Pattern
```kotlin
// Clean flow: Request → Has Access? → Show Content
when {
    permissionStatus.hasMediaAccess -> showGallery()
    else -> showPermissionRequest()
}
```

## Best Practices

### 1. Version-Appropriate Permission Sets
```kotlin
private val requiredPermissions = when {
    Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE -> {
        // Android 14+ - Include limited access permission
        arrayOf(READ_MEDIA_IMAGES, READ_MEDIA_VIDEO, READ_MEDIA_VISUAL_USER_SELECTED)
    }
    Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {
        // Android 13 - Granular media permissions
        arrayOf(READ_MEDIA_IMAGES, READ_MEDIA_VIDEO)
    }
    else -> {
        // Android 10-12 - Legacy storage permission
        arrayOf(READ_EXTERNAL_STORAGE)
    }
}
```

### 2. Single Permission Request
```kotlin
// Request all permissions in one operation per Android docs
permissionLauncher.launch(permissionManager.getAllPermissions())
```

### 3. Minimum SDK Strategy
- **Bump to API 29** eliminates Android 9 edge cases
- **Cleaner permission model** throughout supported range
- **97%+ device coverage** with much simpler code

## Code Health Metrics
- **Reduced complexity**: Removed 5 unused states/composables  
- **Better UX**: No complex "permanently denied" flows
- **Maintenance**: Single permission detection path per Android version

## Anti-Patterns Avoided
1. **Tracking permanent denial manually** - Let Android handle it
2. **Complex limited access UI** - Treat as transparent to app
3. **Multiple permission request flows** - Use single Material3 bottom sheet
4. **Supporting very old Android versions** - Focus on modern baseline

## Future Considerations
1. **Photo Picker Integration**: For apps wanting zero permissions
2. **Scoped Storage Optimization**: Direct file access patterns for Android 11+
3. **Privacy Dashboard**: Prepare for enhanced permission monitoring

### Visualization of the Solution
```
User Action → System Permission Dialog → Binary Result
[Allow All] → READ_MEDIA_* granted → App sees all photos
[Allow Limited] → READ_MEDIA_VISUAL_USER_SELECTED granted → App sees selected photos  
[Deny] → No permissions → Show retry option
```